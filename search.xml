<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浏览器上给定URL的具体访问过程]]></title>
    <url>%2F2018%2F11%2F08%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8A%E7%BB%99%E5%AE%9AURL%E7%9A%84%E5%85%B7%E4%BD%93%E8%AE%BF%E9%97%AE%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1、Http协议基于应用层的一个规范标准，通信双方都要遵守 2、一次Http请求的完整过程1、浏览器输入一个地址，首先要进行域名解析，浏览器先去系统的host文件查找有没有域名对应的IP，如果没有再去本地DNS服务器（由运营商提供）查询是否有对应的IP地址； 2、本地DNS服务器如果没有，需要到根域服务器查询，查询方式有两种： 迭代查询 当遇到自己服务器不能回答的DNS查询请求时，把能解析该域名的服务器地址返回给客户端DNS程序，最终客户端只和一台服务器进行了域名/IP信息的传送 递归查询 当遇到自己服务器不能回答的DNS查询请求时，它会逐级往下向其他DNS服务器进行查询，最后所有参与此次查询IP的服务器都会得到该域名和对应IP信息 3、经过DNS服务器解析之后客户端得到域名的IP地址，首先发起TCP连接请求（三次握手）； 4、建立起TCP连接之后，客户端发起Http请求； 5、连接建立之后服务端进行响应，客户端接收响应并展示给用户； 6、浏览器得到HTML代码，会进行解析，这个过程中可能还会不断通过Ajax向服务端发起异步加载的请求，最终将页面完整展示 3、GET和POST请求的区别1、GET请求中的参数包含在URL中，数据可以在URL中看到，而POST请求的URL不会包含这些数据，数据都是通过表单形式传输，会包含在请求体中； ２、GET请求提交的数据最多只有1024字节，而POST方式没有限制。 需要提交用户密码和用户名，其中包含敏感信息，使用GET请求的话密码就会暴露在URL中，所以应该选POST。上传文件内容比较大，也应该选POST。 4、Http协议的无状态1、无状态是指Http协议对事务的处理没有记忆能力，服务器不知道客户端是什么状态 2、保持状态的两种技术：session和cookie。session保存在服务端，cookie保存在客户端 3、浏览器关闭cookie消失，但是session是服务器端的，不会被删除。 5、Https协议 = Http协议 + SSL（安全套接字）1、https减低用户访问速度，因为多了很多次握手 2、安全 所有信息都是加密的 有校验机制，一旦篡改通信双方都会发现； 配备身份证书，防止身份被冒充]]></content>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM知识点总结]]></title>
    <url>%2F2018%2F10%2F12%2FJVM%2F</url>
    <content type="text"><![CDATA[1、内存区域1、堆内存 所有的对象实例都存放在堆内存，所有线程共享的堆内存 Java堆自动化管理，通过垃圾回收机制自动清理垃圾对象 分为新生代（Eden、s0、s1）和老年代 2、栈 线程私有的内存空间（三部分：局部变量表、操作数栈、帧数据区） 随着线程的结束而结束 3、方法区 线程共享，保存已经被加载的类信息、方法、常量池、静态变量、即时编译器编译后的代码数据。 可以理解为永久区 这部分的内存回收主要是针对常量池的回收和对类型的卸载 4、CAS（Compare And Swap）1234执行函数：CAS（V,E,N） V表示需要读写的内存位置 E表示进行比较的预期原值 N表示打算写入的新值 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置的值更新为新值，否则不做任何操作。CAS操作是原子的。 5、如果是建立过多线程导致的内存溢出，在不能减少线程数或者更换64位虚拟机的情况下，只能通过减少最大堆和减少栈容量来换取更多的线程。2、垃圾回收1、对象是否存活（判断一个对象是否可回收的方法） 引用计数法 给对象添加一个计数器，有引用值加1，引用失效值减1，当计数器值为0时，该对象不能再被使用缺点：存在对象之间相互循环引用的问题导致对象无法被回收，占用资源 可达性分析算法 通过“GC Roots”对象为起始点，当一个对象到GC Roots没有任何引用链相连，则该对象不可用，将会被回收。 2、引用 强引用 类似” Object obj = new Object()“这类声明对象引用，只要对象存在强引用就不会被回收 软引用 做缓存用，有用并非必需的对象。在内存溢出之前会被回收以空出内存 弱引用 做缓存用，非必需的对象。只能生存到下一次垃圾回收发生之前 虚引用 唯一目的就是在这个对象在被回收时收到一个系统通知 3、垃圾回收算法 标记-清除算法 标记需要被回收的对象---&gt;标记完成后统一回收标记和清除效率都不高；会产生大量不连续的内存碎片 复制算法 内存分两块，一次使用一块，清理的时候将存活的对象复制到另一块内存上，然后全部清理一般分成较大的Eden空间和两块较小的Survivor空间，一次只使用Eden和一块Survivor，当另一块Survivor无法存放上一次新生代收集的存活对象则这些对象会通过分配担保机制进入老年代。对象到达一定的年龄也会自动进入老年代，对象年龄由GC次数决定 标记-整理算法 标记需要回收的对象，然后让所有存活的对象向一端移动，清理端边界外的内存 新生代使用复制算法，老年代使用标记-整理算法 4、垃圾收集器 Serial收集器 单线程，垃圾收集的时候必须暂停其他所有线程的运行优点：简单高效。 新生代收集器 ParNew收集器 Serial的多线程版本新生代收集器 Parallel Scavenge收集器 新生代收集器，使用复制算法，并行多线程目标是达到设定的吞吐量目标，吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间） Serial Old收集器 Serial的老年代版本，使用标记-整理算法 Parallel Old收集器 Parallel Scavenge的老年代版本，使用多线程和标记-整理算法在注重吞吐量和CPU资源敏感的场合，可以优先考虑Parallel Scavenge和Parallel Old的组合 CMS（Concurrent Mark Sweep）收集器 获取最短回收停顿时间，基于标记-清除算法 优点：并发收集、低停顿缺点： 对CPU资源非常敏感 无法处理浮动垃圾，可能出现Concurrent Mode Failure​而导致另一次Full GC的产生 标记-清除算法产生大量空间碎片，容易导致没有足够空间来分配给大对象，这样就会提前触发一次Full GC G1收集器 面向服务端应用的垃圾收集器 优点： 并行与并发：利用多核多CPU缩短停顿时间 空间整合：整体使用标记-整理算法，局部使用复制算法，收集垃圾后能提供规整的可用内存 分代收集：将堆分成一块块的区域，新生代和老年代不再是物理上隔离的 可预测的停顿 5、内存分配与回收 对象优先在新生代Eden区分配 当Eden区空间不够时，虚拟机会发起一次Minor GC（发生在新生代的GC，比较频繁，回收速度也快） 大对象直接进入老年代 大对象就是需要大量连续内存的对象 长期存活的对象进入老年代 动态对象年龄判定 如果Survivor空间中相同年龄的所有对象占有空间超过Survivor的一半，则大于等于该年龄的对象直接进入老年代 空间分配担保 JDK6之后的规则：只要老年代的连续内存空间大于新生代对象的总大小或历次晋升的平均大小就会进行Minor GC，否则进行Full GC 3、JDK工具 jps（JVM Process Status Tool）虚拟机进程状况工具 列出正在运行的虚拟机进程，显示虚拟机执行主类名称，以及这些进程的本地虚拟机唯一ID（LVMID） jstat（JVM Statistics Monitoring Tool）虚拟机统计信息监视工具 可以显示本地或远程虚拟机进程的类加载、内存、垃圾收集、JIT编译等运行数据 jinfo（Configuration Info for Java ）Java配置信息工具 实时查看和调整虚拟机各项参数 jmap（Memory Map for Java）内存映像工具 主要用于生成堆转储快照 jstack（Stack Trace for Java）堆栈跟踪工具 用于生成虚拟机当前时刻的线程快照线程快照：当前虚拟机每一条线程正在执行的方法堆栈的集合 4、类加载1、Class类文件Class文件是一组以八位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑排列 2、类加载的生命周期从类被加载到虚拟内存到卸载出内存为止，整个生命周期：加载--&gt;验证--&gt;准备--&gt;解析--&gt;初始化--&gt;使用--&gt;卸载 1、对一个类的主动引用会触发初始化（在之前加载、验证、准备需要开始），有且只有以下五种情况： 遇到 new、getstatic、putstatic、invokestatic这四条字节码指令时 使用java.lang.reflect包的方法对类进行反射调用时 初始化一个类时，如果其父类还没初始化则要先初始化父类 虚拟机启动时要指定一个要执行的主类（包含main方法的类），虚拟机先初始化这个类 使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄对应的类没有初始化，则需要先对这个类初始化 其他都称为被动引用，不会触发初始化。被动引用的例子： 通过子类引用父类的静态字段，不会导致子类的初始化 通过数组定义来引用类，不会触发此类的初始化 123456789101112131415public class SuperClass()&#123; static &#123; System.out.println(&quot;SuperClass init&quot;); &#125; public static int value = 123;&#125;public class SubClass extends SuperClass &#123; static&#123; System.out.println(&quot;SubClass init&quot;); &#125;&#125;//引用静态字段SubClass.value;//数组定义引用SuperClass[] sca = new SuperClass[10]; 常量在编译阶段会存入调入类的常量池中，本质上没有直接引用定义常量的类，因此不会触发定义常量的类初始化 接口的初始化与类的初始化的区别是五种有且仅有​前三种：父接口只有在使用到的时候才会初始化 2、类加载1、验证 文件格式验证 基于二进制字节流进行 元数据验证 字节码验证 符号引用验证 2、准备 正式为类变量分配内存并设置初始值，这里的类变量是指被static修饰的变量，内存分配不包括实例变量；初始值一般是数据类型的零值，特殊情况比如被final修饰，则会直接赋值。 3、类和加载它的类加载器确定了其在Java虚拟机中的唯一性。 比较两个类是否“相等”，只有在这两个类都由同一个类加载器加载的前提下才有意义。 4、双亲委派模型 启动类加载器 扩展类加载器 应用程序类加载器 自定义类加载器 如果一个类加载器收到类加载的请求，首先不会自己去加载，而是委派给父类加载器去加载，每一层加载器都是如此，因此最后所有的类加载请求都会传送到顶层的启动类加载器，只有父类加载器反馈说自己无法加载，子类加载器才会自己尝试加载。 好处： ​Java类随着类加载器一起具有了层级优先关系，能够有效确保一个类的全局唯一性。如java.lang.object类，由启动类加载器加载，这样object不管在哪个类加载器环境下都是同一个类。 5、虚拟机字节码执行引擎1、栈帧结构栈帧是用于支持虚拟机方法调用和方法执行的数据结构，是虚拟机运行时数据区的虚拟机栈的栈元素，存储着方法的局部变量表、操作数栈、动态连接和方法返回地址等。 局部变量表 容量的最小单位是槽（slot），一个slot能够存放一个32位以内的数据类型64位的数据类型虚拟机会以高位对齐的方式分配连续的两个slot空间slot可以重用 操作数栈 栈元素可以是任何的Java数据类型，32位占容量1，64位占容量2 方法返回地址方法退出等同把当前栈帧出栈，可能的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有）压入调用者栈帧的操作数栈，调整PC计数器的值以指向方法调用指令后的一条指令 2、方法调用方法调用不是方法执行，该阶段唯一任务就是确定被调用方法的版本（调用哪个方法） 解析调用 主要是四类方法的调用：静态方法、私有方法、实例构造器、父类方法解析调用是一个静态过程，在编译期就完全确定，在类加载的解析阶段就会把涉及到的符号引用转化为可确定的直接引用。 分派 静态分派（典型应用：重载） 123456789101112131415161718192021222324252627282930313233 public class StaticDispatch &#123; static abstract class Human&#123;&#125; static class Man extends Human&#123;&#125; static class Woman extends Human&#123;&#125; public void SayHello(Human guy)&#123; System.out.println(&quot;Hello guy&quot;); &#125; public void SayHello(Man man)&#123; System.out.println(&quot;Hello gentleman&quot;); &#125; public void SayHello(Woman woman)&#123; System.out.println(&quot;Hello lady&quot;); &#125; public static void main(String[] args) &#123; Human man = new Man(); Human woman = new Woman(); StaticDispatch st = new StaticDispatch();st.SayHello(man); st.SayHello(woman); &#125;&#125; 输出结果： Hello guy Hello guy Human是变量的静态类型，Man是变量的实际类型，编译器在重载时依据的是变量的静态类型而不是实际类型，静态类型是编译器可知的，所以在编译阶段，javac编译器会根据静态类型选择重载版本。变量的实际类型变化结果只有在程序运行时才确定，在编译的时候无法确定一个对象的实际类型是什么。 动态分派（典型应用：重写） 在运行期根据实际类型确定方法执行版本 虚拟机的虚方法表中存放各个方法实际入口地址，如果子类没有重写方法，那么子类和父类的虚方法表中同一方法的实际地址一样，如果子类重写了，则子类虚方法表中的方法实际入口地址指向子类的版本方法实际地址。 6、内存模型1、主内存和工作内存Java内存模型规定了所有变量存储在主内存中，每条线程有自己的工作内存用于保存被该线程用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，线程的工作内存之间相互隔离，线程之间变量的值传递通过主内存完成。 1、内存模型要求read和load操作、store和write操作必须顺序执行，但不要求连续执行。 2、内存模型规定基本操作的几条规则： 不允许一个线程丢弃最近的assign操作，即一个变量在工作内存中改变了之后必须同步回主内存 如果对一个变量执行lock操作，会清空工作内存中该变量的值，执行引擎使用该变量之前需要执行load或assign操作初始化该变量的值 对一个变量执行unlock操作之前，必须先把变量值同步回主内存 2、volatile关键字1、volatile型变量的两个特性 保证此变量对所有线程的可见性 volatile变量在各个线程下是一致的，但由于Java运算操作的非原子性导致volatile变量在并发下的运算也是不安全的 禁止指令重排序优化 2、对64位的数据类型double和long，虚拟机允许将没有被volatile修饰的64位数据读写操作分两次32位操作进行 3、Volatile变量修饰符如果使用恰当的话，它比synchronized的使用和执行成本会更低，因为它不会引起线程上下文的切换和调度 4、实现原理： 有volatile变量修饰的共享变量进行写操作的时候会多一行以lock为前缀的汇编代码，lock前缀的指令在多核处理器下会引发了两件事情： 将当前处理器缓存行的数据会写回到系统内存。 这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。 3、三个特性 原子性 可见性 一个线程对一个共享变量的修改，另一个线程能够立即得知这个修改final和synchronized也可以保证可见性 有序性 如果在本线程中，所有操作都是有序的，如果在一个线程观察另一个线程，所有操作都是无序的。 4、Java线程1、线程的调度 协同式线程调度 线程的执行时间由线程自身控制，执行完任务后主动通知系统切换到另一个线程好处：实现简单，线程切换对线程本身是可知的，没有同步问题坏处：线程执行时间不可控，线程如果不主动通知系统切换就会一直阻塞 抢占式线程调度 每个线程由系统分配执行时间，通过设定线程优先级决定线程获得分配时间的多少Java就是这种实现 2、线程的五种状态 新建（New） 运行（Runnable） 可能正在执行或者等待CPU分配时间 无限期等待（Waiting） 等待被其他线程显式唤醒 限期等待（Timed Waiting） 等待被系统自动唤醒 阻塞（Blocked） 等待获取一个排他锁 结束（Terminated） 3、线程安全 Java中各种操作共享的数据分为五类： 不可变 不可变的对象一定是线程安全的比如，如果共享数据是基本类型，定义时用final修饰则数据就是不可变的。String类对象调用replace()、subString()等方法时只会返回一个新构造的字符串，本来的字符串值不受影响 绝对线程安全 相对线程安全 线程兼容 线程对立 4、线程安全的实现 互斥同步（阻塞同步） 同步是指多线程并发访问同一共享数据时保证同一时刻只能被一个线程使用；互斥是实现同步的一种手段，临界区、互斥量、信号量都是主要的互斥实现方式。Java中基本的互斥同步就是synchronized 关键字、java.util.concurrent包中的ReentrantLock（可重入锁）问题：进行线程阻塞和唤醒带来的性能问题 非阻塞同步 5、内存泄漏内存泄漏一般可以理解为系统资源（各方面的资源，堆、栈、线程等）在错误使用的情况下，导致使用完毕的资源无法回收（或没有回收），从而导致新的资源分配请求无法完成，引起系统错误。 年老代堆空间被占 java.lang.OutOfMemoryError: Java heap space 根据垃圾回收前后情况对比，同时根据对象引用情况（常见的集合对象引用）分析，基本都可以找到泄漏点。 持久代被占满 java.lang.OutOfMemoryError: PermGen space 主要原因就是大量动态反射生成的类不断被加载，最终导致Perm区被占满,，主要解决方法：设置-XX:MaxPermSize=16m；换用JDK。比如JRocket 堆栈溢出 java.lang.StackOverflowError 一般是递归没返回或者循环调用]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Synchronized关键字]]></title>
    <url>%2F2018%2F10%2F10%2FSynchronized%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[1、作用保证同一时刻只有一个线程执行该段代码，以达到保证并发安全的效果 2、两种用法 对象锁 方法锁、同步代码块锁 类锁 synchronized修饰静态的方法 指定锁位Class对象 3、类锁不管Java对象有多少个实例对象，但是只有一个class对象，通过给class对象上锁达到同步的效果 4、访问同一个对象实例的两个不同的synchronized普通方法，由于默认获取的是this锁，所以会出现串行的情况12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class SychronizedObjectMethod implements Runnable&#123; static SychronizedObjectMethod instance = new SychronizedObjectMethod(); public static void main(String[] args) &#123; Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); t1.start(); t2.start(); while (t1.isAlive() | t2.isAlive()) &#123; &#125; System.out.println("finished!"); &#125; @Override public void run() &#123; if (Thread.currentThread().getName().equals("Thread-0"))&#123; method1(); &#125;else &#123; method2(); &#125; &#125; public synchronized void method1()&#123; System.out.println("我是加锁的普通同步方法1，我叫"+Thread.currentThread().getName()); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+"运行结束"); &#125; public synchronized void method2()&#123; System.out.println("我是加锁的普通同步方法2，我叫"+Thread.currentThread().getName()); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+"运行结束"); &#125;&#125; 当把method2加上static时，这两个方法同步时获取的锁就不是同一个锁了，所以会并行执行这两个方法 5、小结 一把锁只能同时被一个线程获取 每个实例都对应有自己的一把锁，不同的实例之间互不影响。例外：锁对象时*.class以及synchronized修饰的static方法时，所有的对象共用同一把锁 无论是方法正常执行完毕或者方法抛出异常，都会释放锁 6、性质1、可重入 同一线程的外层函数获得锁之后，内层函数可以直接再次获取该锁 可重入原理：加锁次数计数器 2、不可中断（原子性）]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛型与容器]]></title>
    <url>%2F2018%2F10%2F08%2F%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1、泛型 好处：更好的安全性、更好的可读性 Java中因为类型参数会被替换为object，所以泛型中不能用基本数据类型Pair&lt;int&gt; minmax = new Pair&lt;int&gt;(1,100)不合法 2、列表和队列 迭代的陷阱：在迭代的中间调用容器的删除方法```javapublic void remove(ArrayList list) {for (Integer a : list) {if (a &lt;= 100) { list.remove(a) //抛出ConcurrentModificationException } }}/**迭代器内部会维护一些索引位置相关的数据，迭代过程中容器不能发生结构性变化（添加、插入、删除），否则索引位置就失效。 /&gt; 1、可随机访问，按照索引访问效率高 2、除非数组已排序，否则按照内容查找元素效率低，性能与数组长度成正比3、添加N个元素效率为O(N)，N为数组长度4、插入和删除元素效率低，因为需要移动元素，具体为O(N) LinkedList内部是双向链表实现，每个元素在内存都是单独存放 1、按需分配空间 2、不可以随机访问，按照索引访问效率低3、不管是否排序，按照内容查找元素效率都低4、两端添加、删除元素效率高5、中间插入、删除元素要先定位，效率较低，但修改本身效率很高 ArrayDeque实现了双端队列，内部使用循环数组实现 1、两端添加、删除效率很高 2、根据元素内容查找和删除的效率较低3、没有索引位置的概念，不能根据索引进行操作 3、Map和Set HashMap：实现Map接口，内部有一个哈希表即数组table，每个table[i]指向一个单向链表，根据键存取值，用键算出hash值，取模得到数组中的索引位置buketIndex，然后操作table[buketIndex]指向的单向链表 1、根据键存取值效率很高 2、键值对没有顺序，因为hash值是随机的3、线程不安全 HashSet set是没有重复元素，不保证顺序的容器接口 与HashMap类似，HashSet要求元素重写hashCode和equals方法 实现set接口，内部利用HasnMap实现：1、没有重复元素；2、高效添加、删除元素以及判断元素是否存在；3、没有顺序 排序二叉树 TreeMap和TreeSet的实现基础 顺序特点：左子树所有节点小于该节点，右子树所有节点大于gai 基本的保存、删除、查找效率为O(h),h为树的高度 AVL树保证树的高度平衡，红黑树保证大致平衡 TreeMap 按键而不是按值有序，它要么键实现Comparable接口，要么创建时传递一个Comparator对象 内部是红黑树实现的 根据键保存、查找、删除效率较高，O(h) TreeSet 实现了：排重和有序。排重是基于比较结果的 基于TreeMap 没有重复元素 添加、删除元素，判断元素是否存在效率较高 有序 要求Comparable接口或者通过构造方法提供一个Comparator对象 LinkedHashMap 是HashMap的子类，内部还有一个双向链表维护键值对的顺序 插入顺序：先添加的在前面，后添加的在后面，修改操作不影响顺序 访问顺序：最末尾的是最近访问的，最开始的是最久没被访问的，因为对一个键执行get/put操作后对应的键值对会移到链表末尾 用于缓存 1、缓存就是用来保存常用的数据，容量小访问快 2、LRU是缓存里一种流行的替换算法，即当缓存满了，最近最少使用的先被清理出去 内部维护一个单独的双向链表，默认是插入顺序 EnumSet：用位向量实现 位向量就是用一个位表示一个元素的状态，一组位表示一个集合的状态，每个位对应一个元素，状态只有两种 4、堆与优先级队列 堆 是完全二叉树（给定任意一个节点可以根据其编号直接快速计算出其父节点和孩子节点编号） 逻辑概念上是一颗完全二叉树，物理存储上使用数组，还有一定的顺序要求 根据顺序分为：最大堆和最小堆 最大堆：每个节点都不大于其父节点。最小堆相反 添加和删除元素的时候有两个关键的过程以保持堆的性质，一个是向上调整一个是向下调整 PriorityQueue优先级队列 队列长度没有限制，每个元素都有优先级，队头的元素优先级最高 内部用堆实现，内部元素不是完全有序的，不过逐个出队会得到有序的输出 查看头部元素效率很高，O(1),入队出队效率较高，O(log2(N)) 根据值查找和删除元素效率比较低，O(N) 求中值：元素是动态添加（用一个最大堆一个最小堆） 步骤： 1、设当前中位数为m，最大堆维护&lt;=m的元素，最小堆维护&gt;=m的元素，但两个堆都不包含m 2、当新元素e到达与m进行比较，若e&lt;=m将其加入最大堆，反之加入最小堆 3、第2步之后如果最大堆和最小堆元素个数差&gt;=2，则将m加入元素个数少的堆中，然后从元素个数多的堆将根节点移除并赋值给m]]></content>
      <tags>
        <tag>读书笔记</tag>
        <tag>Java编程的逻辑</tag>
      </tags>
  </entry>
</search>
